# Симметричный блочный шифр "Магма" (ГОСТ Р 34.12-2015)

Проект реализует алгоритм шифрования «Магма», утверждённый стандартом ГОСТ Р 34.12-2015. 
Программа позволяет зашифровать и расшифровать данные в режимах ECB и CBC с использованием 256-битного ключа и 64-битного вектора инициализации (для CBC).

Алгоритм представляет собой точную копию алгоритма блочного шифрования из старого советского ГОСТ 28147—89, за исключением одного изменения. В новом ГОСТ 34.12—2015 определена и задана таблица перестановок для нелинейного биективного преобразования, которая в старом ГОСТ 28147—89 отсутствовала, и организация оставляла за собой право реализации или выбора s-боксов.

---

## Теоретическое описание алгоритма

Алгоритм «Магма» относится к блочным симметричным шифрам и имеет следующие особенности:

- **Длина шифруемого блока:** 64 бита.  
  Перед шифрованием 64-битный блок делится на две равные части по 32 бита – левую (A0) и правую (A1).

- **Длина ключа:** 256 бит.  
  Исходный ключ разбивается на 8 подклучей по 32 бита.

- **Раунды шифрования:** 32 итерации (раунда).  
  Для каждого раунда используется раундовый ключ, который определяется следующим образом:
  - Первые 24 раунда используют 8 подклучей, повторённых три раза.
  - Последние 8 раундов используют 8 подклучей в обратном порядке.

- **Структура раунда:**  
  Каждый раунд (за исключением тридцать второй, где обмен местами не производится) строится по принципу сети Фейстеля и включает следующие шаги:
  
  1. **Сложение по модулю 2^32:** Правая часть (32 бита) складывается с текущим раундовым ключом.
  2. **Нелинейное преобразование (S-box):** Полученное 32-битное число делится на 8 4-битных блоков (нибблов). Для каждого ниббла применяется соответствующая таблица подстановок, которая заменяет исходное 4-битное значение на другое.
  3. **Циклический сдвиг:** Результат нелинейного преобразования циклически сдвигается влево на 11 разрядов. При этом выбывающие биты «окружаются» и попадают в правую часть числа.
  4. **Операция XOR:** Полученное значение ксорится с левой частью блока.
  5. **Перестановка:** Результат (новое значение правой части) записывается, а текущая правая часть переходит на место левой. В последнем раунде обмен местами не выполняется – объединяются итоговая левая и правая части.

- **Режимы работы:**  
  Программа поддерживает режим ECB (Electronic Codebook), в котором каждый 64-битный блок обрабатывается независимо, и режим CBC (Cipher Block Chaining), где предыдущий зашифрованный блок используется для обработки следующего блока посредством операции XOR.

- **PKCS#7 Padding:**  
  Для работы с данными произвольной длины применяется схема дополнения PKCS#7, которая гарантирует, что длина данных будет кратна 8 байтам (64 бита).

### Процесс работы алгоритма
В алгоритме блок, подлежащий зашифрованию (64 бита), разделяется на 2 равные по длине части — левую (старшие 32 бита) и правую (младшие 32 бита). Далее выполняется 32 итерации с использованием итерационных ключей, получаемых из исходного 256-битного ключа шифрования.

Во время каждой итерации (кроме 32й) с левой и правой половиной зашифровываемого блока производится одно преобразование, основанное на сети Фейстеля. 

Сначала правая часть складывается по модулю 32 с текущим итерационным ключом, затем полученное 32-битное число делится на восемь 4-битных чисел и каждое из них, используя таблицы перестановки, преобразуется в другое 4-битное число (нелинейное биективное преобразование). После этого преобразования полученное число циклически сдвигается влево на 11 разрядов. Далее результат XOR-ится с левой половиной блока. Получившееся 32-битное число записывается в правую половину блока, а старое содержимое правой половины переносится в левую половину блока.

В ходе последней (32й) итерации, аналогично вышеописанному процессу, преобразуется правая половина, после чего полученный результат пишется в левую часть исходного блока, а правая половина сохраняет свое значение.

Итерационные ключи получаются из исходного 256-битного ключа. Исходный ключ делится на восемь 32-битных подключей, и далее они используются в следующем порядке: 3 раза с 1-го по 8-й, и 1 раз с 8-го по 1-й.

Для расшифрования используется такая же последовательность итераций, как и при зашифровании, но порядок следования ключей изменяется на обратный.

---

## Описание режима CBC

**Cipher Block Chaining (CBC)** — это режим блочного шифрования, в котором каждый блок открытого текста перед зашифрованием XOR-ится с результатом зашифрования предыдущего блока (или с вектором инициализации [IV] для самого первого блока). 

### Основные этапы работы алгоритма в режиме CBC:

1. **Инициализация:**  
   - Для первого блока используется вектор инициализации (IV).  
   - Вектор инициализации (64 бит) может быть задан явно или сгенерирован случайным образом.

2. **XOR с предыдущим зашифрованным блоком:**  
   - Для **первого** блока открытых данных происходит XOR с IV.  
   - Для **каждого следующего** блока происходит XOR с результатом **предыдущего** зашифрованного блока.

3. **Зашифрование:**  
   - Полученный результат XOR (64 бит) зашифровывается базовым алгоритмом «Магма».  
   - Результат зашифрования сохраняется как «предыдущий зашифрованный блок» для следующей итерации.

4. **Расшифрование:**  
   - При расшифровании каждый 64-битный зашифрованный блок сначала расшифровывается.  
   - После расшифрования результат XOR-ится с предыдущим зашифрованным блоком (или с IV для первого блока).  
   - Таким образом восстанавливается исходный блок открытых данных.

5. **Обработка всех блоков:**  
   - Процесс повторяется для всех блоков, а результат каждого шага используется для следующего.

6. **Преимущество CBC:**  
   - Изменение одного бита в блоке данных приводит к изменению всех последующих блоков, что повышает криптостойкость и скрывает повторяющиеся паттерны.  
   - Для расшифрования требуется тот же вектор инициализации (IV), что и при зашифровании.

---

## Описание работы программы

Программа реализована на Python и содержит два основных режима работы:

1. **Интерактивный режим (interactive_mode):**  
   Если программа запущена без аргументов командной строки, пользователю последовательно предлагается ввести:
   - Операцию: шифрование или расшифрование.
   - 256-битный ключ в шестнадцатеричном формате (64 символа).
   - Режим работы: ECB или CBC.  
     При выборе CBC пользователю может быть предложено ввести вектор инициализации (IV) или сгенерировать случайный IV.
   - Источник данных: текстовая строка или файл.
   - Режим вывода: результат выводится на консоль или сохраняется в файл.

2. **Режим работы через аргументы командной строки (arguments_mode):**  
   С помощью параметров командной строки можно задать:
   - **Операция:** `-e/--encrypt` для зашифрования или `-d/--decrypt` для расшифрования.
   - **Ключ:** параметр `-k/--key` — 256-битный ключ в формате hex (64 символа).
   - **Режим шифрования:** `-m/--mode` с выбором между `ecb` и `cbc`.
   - **Вектор инициализации (для CBC):** `-v/--iv` (16 hex-символов).
   - **Источник данных:** `-t/--text` для текста или `-i/--input` для указания файла с данными.
   - **Вывод результата:** `-o/--output` — путь к выходному файлу (если не указан, результат выводится в консоль).

### Структура кода

- **Классы `Magma` и `MagmaCBC`:**  
  - Реализуют базовые операции алгоритма «Магма»: подготовку раундовых ключей, работу S-box, циклический сдвиг, разделение блока, а также функции для шифрования и дешифрования 64-битных блоков.
  - В проекте класс `MagmaCBC` наследует базовый класс `Magma` и переопределяет методы `encrypt()` и `decrypt()` таким образом, чтобы учитывать XOR с предыдущим блоком и использовании вектора инициализации (IV).

- **Функции `interactive_mode()` и `arguments_mode()`:**  
  - Обеспечивают два способа запуска программы.
  - В интерактивном режиме пользователь вводит данные через консоль.
  - В режиме с аргументами командной строки используются параметры, передаваемые при запуске скрипта.

- **Модуль `PKCS7Padding`:**  
  - Отвечает за дополнение (padding) данных по схеме PKCS#7. Он гарантирует, что длина данных будет кратна размеру блока (8 байт), добавляя в конец данных k байт, значение каждого из которых равно k. При расшифровке последний байт указывает, сколько байт было добавлено, и они удаляются.

- **Функция `main()`:**  
  - Определяет, какой режим запуска использовать (интерактивный, если аргументы отсутствуют, или аргументированный).

---

## Модуль PKCS#7 Padding

Модуль `PKCS7Padding` реализует механизм дополнения (padding) данных для блочных шифров, чтобы длина исходного сообщения была кратна размеру блока. Ниже приведён подробный разбор функционала модуля:

### Класс `PKCS7Padding`

```python
class PKCS7Padding:
    """
    PKCS#7 padding - механизм, позволяющий привести длину данных к нужному кратному размеру блока, который требуется для блочных шифров.
    - Дополняет данные до кратного размера блока, добавляя k байт со значением k.
    - При расшифровке последний байт сообщает, сколько байт padding было добавлено, и они удаляются.
    - Это позволяет гарантировать, что после шифрования и расшифрования исходные данные сохраняются корректно.
    """
    ALWAYS_PADDED: bool = True
```

- **ALWAYS_PADDED:**  
  Флаг, указывающий, всегда ли следует добавлять padding даже в случае, когда данные уже кратны размеру блока.

### Метод `pad`

```python
    def pad(cls, data: bytes, block_size: int = 8, always_padded: bool = None) -> bytes:
        """
        Дополняет данные по схеме PKCS#7 до кратного размера block_size.
        :param data: исходные данные
        :param block_size: размер блока (по умолчанию 8 байт)
        :param always_padded: если True, padding добавляется всегда, даже если данные уже кратны размеру блока.
        :return: данные с padding
        """
```

- **Пояснение:**
  - Вычисляется остаток от деления длины данных на размер блока.
  - Если данных достаточно и они уже кратны блоку, а параметр `always_padded` выключен, возвращаются исходные данные.
  - В противном случае вычисляется количество байт, необходимых для дополнения (`pad_len`), и создаётся последовательность байтов, каждый из которых равен `pad_len`.
  - Дополнение (padding) добавляется в конец данных.

### Метод `unpad`

```python
    def unpad(cls, data: bytes, always_padded: bool = None) -> bytes:
        """
        Удаляет padding, добавленный PKCS#7.
        :param data: данные с padding
        :param always_padded: флаг, указывающий, что padding всегда присутствует
        :return: данные без padding
        """
```

- **Пояснение:**
  - Метод получает последний байт данных, который указывает, сколько байт padding было добавлено.
  - Проверяются корректность значения padding и соответствие всех последних байт значению `pad_len`.
  - Если padding корректен, он удаляется, и возвращаются исходные данные без дополнения.

---

## Варианты запуска программы

Программа поддерживает два основных режима запуска:

### 1. Интерактивный режим

Запуск без параметров:
```console
python magma.py
```
В этом режиме программа:
- Запросит выбор операции (зашифрование/расшифрование).
- Попросит ввести 256-битный ключ в формате hex (64 символа).
- Предложит выбрать режим шифрования (ECB или CBC).  
  При выборе CBC можно ввести вектор инициализации (16 hex-символов) или выбрать автоматическую генерацию случайного IV.
- Запросит источник данных: текст для обработки или путь к файлу (в бинарном формате).
- Предложит выбор вывода результата: консоль или файл.
- После обработки результат будет выведен согласно выбору пользователя.

### 2. Запуск через терминал с параметрами

Запуск программы с использованием аргументов командной строки:
```console
python magma.py -e -k <ключ> -m <режим> -t <текст> [-v <IV>] [-o <выходной_файл>]
```
**Описание параметров:**

- `-e` или `--encrypt`  
  Указывает на операцию зашифрования. Для расшифрования используется `-d` или `--decrypt`.

- `-k <ключ>`, `--key <ключ>`  
  Обязательный параметр. Передаётся 256-битный ключ в формате hex (64 символа).  
  Пример:  
  ```
  -k ffeeddccbbaa99887766554433221100f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff
  ```

- `-m <режим>`, `--mode <режим>`  
  Режим шифрования: `ecb` или `cbc`. По умолчанию используется `ecb`.  
  Пример:  
  ```
  -m cbc
  ```

- `-v <IV>`, `--iv <IV>`  
  Вектор инициализации для режима CBC. Должен быть длиной 16 hex-символов (8 байт).  
  Пример:  
  ```
  -v 0123456789abcdef
  ```

- `-t <текст>`, `--text <текст>`  
  Текст для обработки. Если производится зашифрование, текст берётся как строка, если расшифрование — ожидается hex-строка.  
  Пример:  
  ```
  -t "Шифрование/расшифрование на основе шифра Магма (ГОСТ Р 34.12-2015)"
  ```

- `-i <файл>`, `--input <файл>`  
  Альтернативный способ указания источника данных – путь к входному файлу (в бинарном формате).

- `-o <файл>`, `--output <файл>`  
  Путь для сохранения результата в файл (в бинарном формате). Если не указан, результат выводится в консоль.

---

## Примеры вариантов запуска

### Пример 1. Запуск в интерактивном режиме

Запуск скрипта без аргументов:
```console
python magma.py
```
Пример диалога в консоли:
```console
*** Шифрование/расшифрование на основе шифра "Магма" (ГОСТ Р 34.12-2015) ***
-------------------------------------------------------------------------------------------------

Выберите операцию шифрования (зашифровать - [encrypt], расшифровать - [decrypt]): encrypt
Введите 256-битный ключ (64 hex-символа): ffeeddccbbaa99887766554433221100f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff
Выберите режим работы (ECB/CBC): ECB
Выберите источник данных (текст - [text], файл - [file]): text
Введите текст: Шифрование/расшифрование на основе шифра Магма (ГОСТ Р 34.12-2015)
Куда вывести результат (консоль - [console], файл - [file]): console

Зашифрованный текст:
90cc275a2ccb05aa7107cbc8296f886d9c505275984af877ea89ec2e5e2518e2d271eece242b9548cec7caf10f58aaa2e43482a07ca17e5ec5ce124426f01848da6ed52dcb7502d6f646184142d1846304c13a43141db541a4fee6855b18d3b44329c8de219d40158aa5cf797a55f6c371924cef493a5137
```

### Пример 2. Запуск через терминал с аргументами (ECB режим)

```console
python magma.py -e -k ffeeddccbbaa99887766554433221100f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff -m ecb -t "Шифрование/расшифрование на основе шифра Магма (ГОСТ Р 34.12-2015)"
```
Программа выполнит операцию зашифрования в режиме ECB и выведет результат в консоль.

### Пример 3. Запуск через терминал с аргументами (CBC режим)

```console
python magma.py -e -k ffeeddccbbaa99887766554433221100f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff -m cbc -v 0123456789abcdef -t "Шифрование/расшифрование на основе шифра Магма (ГОСТ Р 34.12-2015)" -o encrypted.bin
```
В данном примере:
- Шифруется текст с использованием режима CBC.
- Вектор инициализации задан явно как `0123456789abcdef`.
- Результат шифрования сохраняется в файл `encrypted.bin`.

---

## Тестовые данные

Для проверки работы программы можно использовать следующие тестовые данные:

- **Ключ (256 бит, hex):**  
  `ffeeddccbbaa99887766554433221100f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff`

- **Вектор инициализации (64 бит, hex):**  
  `0123456789abcdef`

- **Открытый текст:**  
  `Шифрование/расшифрование на основе шифра Магма (ГОСТ Р 34.12-2015)`

- **Зашифрованный текст (ECB режим):**  
  `90cc275a2ccb05aa7107cbc8296f886d9c505275984af877ea89ec2e5e2518e2d271eece242b9548cec7caf10f58aaa2e43482a07ca17e5ec5ce124426f01848da6ed52dcb7502d6f646184142d1846304c13a43141db541a4fee6855b18d3b44329c8de219d40158aa5cf797a55f6c371924cef493a5137`

- **Зашифрованный текст (CBC режим):**  
  `be9bdbd1238d458e610248cff00cf98a14527af5c227c4b27ea951fc1d968db58c66bd1660abc0e81844d213291feeb1bda21346f657a6ee988bdf9a59cd0b9422d2680d65d2022d19aaf304f90e28b3506eae7b8f38e23cd0ff9696c53d00d49708fc4467f5d1f3956843405e2fd710d8a2064d8b4b3f93`

---